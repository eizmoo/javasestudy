# 缓存的两种更新方法
- 更新
- 淘汰
相比于更新，淘汰会多一次cache miss。
更新操作可能会需要额外的IO操作去查库或者重新计算。
所以在绝大部分场景下，淘汰比更新需要的性能更小，所以推荐直接淘汰，在下次请求cache miss之后再进行操作放入缓存。

# 先操作缓存还是先操作数据库？
### 先操作缓存
#### 更新缓存
先更新缓存，然后在缓存设置成功的情况下，如果数据库操作失败，产生了事务不一致。此时缓存与数据库中的数据不一致。
#### 淘汰缓存
先淘汰缓存，在淘汰成功的情况下，再去操作数据库。
问题出在两个线程并发读写的情况下：线程1写操作去修改缓存成功，再去试图写入数据库，即锁表
线程2读操作是在线程1缓存修改成功之后进入，因为cache miss，回去数据库中查询数据。此时有可能出现线程2先读到了还未更新的数据库中数据，最终导致缓存中设置的是还未更新的值，缓存与数据库中的数据不一致，而且出现的几率很高。
![并发读写导致脏数据](https://user-gold-cdn.xitu.io/2018/5/11/1634fc3319a4ddb5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
### 先操作数据库
#### 更新缓存
操作完数据库之后，更新数据库。
并发写的场景下，可能出现两个线程因为时间先后顺序不同导致缓存出现脏数据。
线程1在更新完数据库早于线程2，但是线程2的更新缓存晚于线程1，此时缓存你中的值将会不是最新的值，即缓存中出现脏数据。
![并发写导致脏数据](https://user-gold-cdn.xitu.io/2018/5/11/1634fc3319beda97?imageslim)
#### 淘汰缓存
先操作数据库再淘汰缓存，是所有情况下最为稳妥的方式。
可能出现并发的场景为：线程1读缓存未命中，去数据库中获取到数据之后，然后线程2锁表开始写数据，写完成后将缓存删除，此时线程1再去更新缓存中的值(因为读是读得后再去更新)，这时候缓存的数据就是之前的脏数据
。
![并发读写导致脏数据](https://user-gold-cdn.xitu.io/2018/5/11/1634fc331997574e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
这种场景出现的比较苛刻，要在读失效的前提下，读数据库操作发生在写数据库之前，然后写缓存发生在淘汰缓存之后，因为数据库中读的速度远快于写，读完立即去写入，理论上来说要发生在写完后的操作是十分困难的。

# 总结
以上所说的就是最常用的缓存模式Cache Aside，这种模式使用起来十分的简单，但是系统需要同是操作数据库和缓存。
根据上文分析，`操作缓存最好使用先操作数据库再淘汰缓存`的方式。
缓存是通过牺牲强一致性来提高性能的。所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短太长都不好，太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。 

注：文章图片采用[使用缓存的正确姿势](https://juejin.im/post/5af5b2c36fb9a07ac65318bd#heading-11)
