# JAVA中的几种基本数据类型是什么，各自占用多少字节
  
- byte 1字节  -128～127
- short 2字节 -32768～32767
- char 2字节 0~65535
- int 4字节 -2147483648~2147483647
- long 8字节 -9223372036854775808~9223372036854775807
- float 4字节 1.4E-45~3.4028235E38
- double 8字节 4.9E-324~1.7976931348623157E308
- boolean 1字节 true|false

# 基本类型自动装拆箱
### 装、拆箱方法
装箱使用valueOf()方法，拆箱使用xxValue() (例如Integer::intValue，返回的是int) 

### 缓存
装箱时(使用了valueOf()方法)，包装类有自有的缓存，缓存-128～127之间的包装类(Character是0～127)
Float和Double无缓存值。Boolean缓存的是true和false(全部值)，Byte缓存的也是全部值。

可以通过启动时的配置 `-Djava.lang.Integer.IntegerCache.high=100` 来配置缓存的上限。

### 缓存意义
缓存的意义目的主要是节省内存，由于更好的缓存效率，这也可以带来更快的代码。

基本上，Integer该类保留了Integer-128到127范围内的实例缓存，并且所有自动装箱，文字和用法Integer.valueOf()都将从该缓存中返回其覆盖范围的实例。

这是基于这样的假设，即这些小值比其他整数更频繁地出现，因此避免为每个实例使用不同对象的开销是有意义的（Integer对象占用12个字节之类的东西）。

# String类能被继承吗，为什么
不可继承，因为是final修饰的类。
### 优点 
- 线程安全
- 字符串池
- 创建HashCode不可变性

#String，StringBuffer，StringBuilder的区别
String是不可变的字符串类，内部采用final char[]数组维护
String在拼接时是通过创建SpringBuilder对象生成新的String对象
buffer和builder都是提供多次拼接append方法，不同在于buffer在一些方法上加了synchronized关键字，线程安全，但是速度会慢于builder

# ArrayList和LinkedList有什么区别。
底层一个是数组一个是双向链表，所以差异就在数据结构上
arrayList 随机读取，读O(1)，插入的平均时间复杂度O(n)，因为是数组，需要动态扩容
linkedList 插入O(1)，读取O(n)，不需要动态扩容，但是数据量越大读取时间越长，因为是顺序读取

#讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。
1. 基类静态代码块，基类静态成员字段 （并列优先级，按代码中出现先后顺序执行）（只有第一次加载类时执行）
2. 派生类静态代码块，派生类静态成员字段 （并列优先级，按代码中出现先后顺序执行）（只有第一次加载类时执行）
3. 基类普通代码块，基类普通成员字段 （并列优先级，按代码中出现先后顺序执行）
4. 基类构造函数
5. 派生类普通代码块，派生类普通成员字段 （并列优先级，按代码中出现先后顺序执行）
6. 派生类构造函数

# 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
treeMap底层红黑树，实现插入的key可按照规则排序，默认是key的升序
linkedHashMap链表+哈希表，保证插入顺序的哈希表,还有一个参数决定是否在此基础上再根据访问顺序(get,put)排序，通过双向链表维护顺序
hashMap

# 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
- 相同
接口和抽象类不可被实例化
抽象类和1.8之后的接口都可以有未实现的方法和已实现的方法。在抽象类中叫做抽象方法（无实现）和非抽象方法（有实现），接口中有实现的方法叫做默认方法。

- 不同
接口可继承多接口，一个类可实现多个接口;抽象类只能单继承
接口代表has A，抽象类代表is A，即抽象类是对本质的抽象，接口是对行为的抽象
继承抽象类的类如果不是抽象类，那么一定要继承方法。抽象类中的方法不能是static和private的

# 反射的原理，反射创建类实例的三种方式是什么。
- 通过对象.getClass（）方式
- 通过类名.Class 方式
- 通过Class.forName 方式

# 反射中，Class.forName和ClassLoader区别 。
Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块
Class.forName(name,initialize,loader)带参数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。只不过默认是true，所以默认解释并执行类中的static块
ClassLoader就是遵循双亲委派模型最终调用启动类加载器的类加载器，实现的功能是“通过一个类的全限定名来获取描述此类的二进制字节流”，获取到二进制流后放到JVM中。Class.forName()方法实际上也是调用的CLassLoader来实现的。

# 动态代理与cglib实现的区别。
jdk动态代理要求代理类继承于接口
cglib生成代理类的子类，覆盖其中的所有方法，所以该类或方法不能声明称final的
当目标类没有实现接口时，使用cglib，否则使用JDK动态代理(实现接口也可以强制使用cglib)


