# 四种隔离级别
### 三种现象
- 脏读
可能读取到其他事务中未提交的修改数据
- 不可重复读
多次读同一数据，读到的两次数据不一致（其他事务修改）
- 幻读
多次读，行数增加（其他事务插入）

### 隔离级别
- 读未提交 RU
    脏读、不可重复读、幻读
- 读已提交 RC
    不可重复读、幻读
- 可重复读 RR
    幻读，InnoDB默认级别
- 串行读 SERIALIZABLE
    不会出现以上现象，但是串行是只有一个事务可以进行，即单线程。读写都会互相阻塞

# 事务特征
ACID
- 原子性 Atomicity
操作集合认为是个整体，即成功就全部操作成功，失败就全部操作失败
- 隔离性 Isolation
保证多个事务可以并发执行，相互的操作不会受到影响
- 持久性 Durability
每一次的事务提交后就会保证不会丢失
- 一致性 Consistency
AID用来保证C，C是目的，AID是手段

# Mysql知道几种存储引擎，有什么区别

1. MyISAM
   - 不支持事务，不支持外键
   - 只支持表级锁
   - 非聚集索引，数据文件和索引分开，索引保存数据文件指针
2. InnoDB
   - 支持事务，支持外键
   - 支持表锁、行锁
   - 聚集索引，数据文件和索引绑定一起，所以必须要主键(如果没有显式创建会生成默认的主键字段)

3. Memory
   - 内存缓存

# Innodb的行级锁的实现

行级锁是在查询语句命中索引下使用的。通过给索引上的索引项添加锁。

1. 不通过索引的情况下，是表锁
2. 是对索引加锁而不是对记录。所以虽然是访问不同行，如果是同一个索引键(同一个索引值)，仍然会锁冲突。
3. 即使使用了索引，出于mysql的查询优化机制，可能不会走索引导致还是行锁

# Innodb的行级锁有几种

X（写）S（读）

xx、xs互斥、ss并行

# 数据库怎么优化

建表时注意数据库结构，允许部分冗余避免查询时的太多连表。

表主键要递增，这样符合B+设计规则。

列类型尽量小，大的话会影响查询速度。

对表中的常用搜索、排序或分组查询字段增加索引。

增加索引的字段需要有足够大的差异（性别字段就是小差异，身份证号字段就是大差异）

索引要尽可能少，如果可以，索引字段可以不是完整字段值，而是前面一段值，减少非聚集索引占用的空间。(也是注意差异度，有计算公式可以查询差异度)

联合索引注意最左匹配。

尽量使用覆盖索引，较少回标。

及时清楚冗余索引。

# 索引的数据结构B+

是一棵树，只有叶子节点存储数据，非叶子节点存储的是目录项记录。因为非叶子存储的是目录项，所以一个非叶子节点可以存储非常多的目录项，层层下来会导致一颗B+树的层次很低。查找时根据id只需要几次IO就可以在聚簇索引中找到记录。