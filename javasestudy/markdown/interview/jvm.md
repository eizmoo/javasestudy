# 什么情况下会发生栈内存溢出
栈就是方法执行时创建的栈帧超过了jvm配置的栈的深度，所以最可能出现的原因是递归调用方法。
可以通过-Xss配置调整JVM栈大小。

# JVM的内存结构，Eden和Survivor比例
堆、方法区、程序计数器、虚拟机栈、本地方法栈
堆存放内存对象，方法区存放类信息、常量，程序计数器和栈是线程私有，计数器指示栈的下一步执行的语句，栈是方法运行时的结构。
新生代：老年代 = 1：2
Eden和Survivor是堆新生代的结构。Survivor有两个，比率为Eden8Survivor1。
划分的原因在于每次GC的时候会将old Survivor和Eden的不回收对象移动到new Survivor，然后清除掉old和Eden。
然后将new 标记为old，下次再进行这种操作的new区域是不会使用的

# JVM管理的内存结构是怎么样的
堆、方法区、程序计数器、虚拟机栈、本地方法栈

# 不同的虚拟机在实现运行时内存有什么区别
？

# 运行时数据区中哪些区域是线程共享的？哪些是独享的？
线程共享：堆、方法区
线程独享：栈、程序计数器

# 除了JVM运行时内存以外，还有什么区域可以用吗？
堆外内存
在JDK 1.4中引入的NIO中，引入了一种基于Channel和Buffer的I/O方式，
他可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。

# 堆和栈的区别是什么？
1. 堆用于存放对象实例，栈(局部变量表)存放对象引用、基本数据类型
2. 堆线程共享，栈线程独享

# Java中的数组是存储在堆上还是栈上的？
java中的数组是个对象，所以实例存储在堆上，引用保持在栈中

# Java中的对象创建有多少种方式？
1. new Object()
2. 反射 Object.class.newInstance() 
3. 反射 Object.class.getConstructor().newInstance()

对于一个普通的Java对象的创建，大致过程如下：
1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。
2、检查符号引用代表的类是否被加载、解析、初始化过。
3、虚拟机为对象分配内存。
4、虚拟机将分配到的内存空间都初始化为零值。
5、虚拟机对对象进行必要的设置。
6、执行方法，成员变量进行初始化。

# Java中的对象一定在堆上分配内存吗？
在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析
如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。

# 如何获取堆和栈的dump文件？
Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。
可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。

# GC算法

1. 标记清除

   分为标记、清除两个阶段。标记是GCRoot标记的，清除是清除掉没有被标记的无用对象。

   - 缺点

     标记和清除两个阶段效率都不高

     标记清除会导致大量不连续的内存碎片，过多的内存碎片会导致大对象无法存储导致频繁GC

2. 复制

   内存区域分为两块，一块不用。每次GC将存储数据的内存区域中存活的对象复制到另一块内存区域中。

   - 缺点

     浪费一半的内存空间

   现在的新生代算法一般都是复制，因为新生代的大部分对象都是朝生夕死，存活率很低，所以复制的空间只需要一小块。

   eden:from survivor:to survivor=8:1:1

   分配担保：如果从eden存活的超过10%，那么多出的部分会被移入老年代。

3. 标记整理

   与标记清除类似，不过不是清除可回收对象，而是将所有存活对象向一端移动，然后直接清除掉边界以外的内存

4. 分代收集

   根据对象的存活周期不同而划分几块不同的区域，每个区域采用不同的GC算法。

   一般做法是分为新生代和老年代，新生代存活率低使用标记复制(有分配担保做保底)，老年代存活率高使用标记整理(没有分配担保，需要谨慎对待内存空间)

   

   # 垃圾回收器

   垃圾回收器是回收算法的应用。

   1. CMS

      CMS是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现。

      只会处理老年代和永久代，不会处理新生代

      步骤：

      - 初始标记 Stop The World

        仅仅是标记一下GCRoot关联的对象

      - 并发标记

        从GCRoot去追踪堆上的活跃对象，此阶段不停顿，可能出现GCRoot变动

      - 重新标记 Stop The World

        重新标记，修正并发标记过程中的变动对象。时间长过初始标记，但是远小于并发标记

      - 并发清除

      可以说CMS的回收是和用户线程并发执行。

      缺点：

      - 对CPU敏感

        并发阶段不会影响用户线程的执行，但是会占用一部分CPU资源，导致应用程序变慢

      - 无法处理浮动垃圾

        在重新标记过程后出现的垃圾不能及时清除，需要等到下一次的GC

      - 基于标记-清除算法实现

        会产生内存碎片

      2. G1

         G1不再是基于新生代老年代的设计，而是将内存分割成很多个Region，新生代老年代只是多个Region的集合。