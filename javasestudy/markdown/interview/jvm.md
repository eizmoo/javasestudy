# 什么情况下会发生栈内存溢出
栈就是方法执行时创建的栈帧超过了jvm配置的栈的深度，所以最可能出现的原因是递归调用方法。
可以通过-Xss配置调整JVM栈大小。

# JVM的内存结构，Eden和Survivor比例
堆、方法区、程序计数器、虚拟机栈、本地方法栈
堆存放内存对象，方法区存放类信息、常量，程序计数器和栈是线程私有，计数器指示栈的下一步执行的语句，栈是方法运行时的结构。
新生代：老年代 = 1：2
Eden和Survivor是堆新生代的结构。Survivor有两个，比率为Eden8Survivor1。
划分的原因在于每次GC的时候会将old Survivor和Eden的不回收对象移动到new Survivor，然后清除掉old和Eden。
然后将new 标记为old，下次再进行这种操作的new区域是不会使用的

# JVM管理的内存结构是怎么样的
堆、方法区、程序计数器、虚拟机栈、本地方法栈

# 不同的虚拟机在实现运行时内存有什么区别
？

# 运行时数据区中哪些区域是线程共享的？哪些是独享的？
线程共享：堆、方法区
线程独享：栈、程序计数器

# 除了JVM运行时内存以外，还有什么区域可以用吗？
堆外内存
在JDK 1.4中引入的NIO中，引入了一种基于Channel和Buffer的I/O方式，
他可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。

# 堆和栈的区别是什么？
1. 堆用于存放对象实例，栈(局部变量表)存放对象引用、基本数据类型
2. 堆线程共享，栈线程独享

# Java中的数组是存储在堆上还是栈上的？
java中的数组是个对象，所以实例存储在堆上，引用保持在栈中

# Java中的对象创建有多少种方式？
1. new Object()
2. 反射 Object.class.newInstance() 
3. 反射 Object.class.getConstructor().newInstance()

对于一个普通的Java对象的创建，大致过程如下：
1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。
2、检查符号引用代表的类是否被加载、解析、初始化过。
3、虚拟机为对象分配内存。
4、虚拟机将分配到的内存空间都初始化为零值。
5、虚拟机对对象进行必要的设置。
6、执行方法，成员变量进行初始化。

# Java中的对象一定在堆上分配内存吗？
在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析
如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。

# 如何获取堆和栈的dump文件？
Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。
可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。