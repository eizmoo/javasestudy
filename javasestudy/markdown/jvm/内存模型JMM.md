### 概述
分为五大块：堆、方法区、程序计数器、虚拟机栈、本地方法栈

其中线程共享：堆、方法区，线程独享：程序计数器、虚拟机栈、本地方法栈
#### 堆
存放对象实例，是最大的区域，也是GC管理的主要的区域。
在虚拟机启动时创建，几乎所有的对象实例和数组都是在这里分配。
具体的内存模型依托于采用的垃圾回收方式。

JDK1.8之后，运行时常量池从方法区移动到堆中。

#### 方法区
存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。

#### 程序计数器
指示当前线程执行的字节码的下一行的行号，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。
每个线程独享一个程序计数器，保证线程切换后能恢复到正确的执行位置。

程序计数器不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡

#### 虚拟机栈
虚拟机栈是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的
ava虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。
局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

可能会抛出`StackOverflowError`和`OutOfMemmoryError`异常
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
- 如果虚拟机在扩展栈时无法申请到足够的内存，则将抛出OutOfMemoryError异常

#### 本地方法栈
与虚拟机栈非常像，不同点在于执行的是`native`修饰的本地方法。
